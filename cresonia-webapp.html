<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cresonia AI</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>C</text></svg>" type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <style>
        :root {
            --primary-color: #4285f4;
            --primary-hover: #3367d6;
            --secondary-color: #34a853;
            --secondary-hover: #2d9249;
            --tertiary-color: #ea4335;
            --tertiary-hover: #d32f2f;
            --background-color: #f5f5f5;
            --card-color: #fff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #e0e0e0;
            --input-background: #fff;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        [data-theme="dark"] {
            --primary-color: #5f9efa;
            --primary-hover: #4285f4;
            --secondary-color: #46c266;
            --secondary-hover: #34a853;
            --tertiary-color: #f06b63;
            --tertiary-hover: #ea4335;
            --background-color: #202124;
            --card-color: #2c2c2e;
            --text-color: #e8eaed;
            --text-secondary: #9aa0a6;
            --border-color: #3c4043;
            --input-background: #3c3c3e;
            --shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        @media (min-width: 1200px) {
            .container {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .main-header, .settings-section {
                grid-column: 1 / span 3;
            }
        }
        
        @media (min-width: 768px) and (max-width: 1199px) {
            .container {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .main-header, .settings-section {
                grid-column: 1 / span 2;
            }
            
            .evaluation-section {
                grid-column: 1 / span 2;
            }
        }

        .main-header {
            text-align: center;
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }
        
        .settings-section {
            grid-column: 1 / -1;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo {
            width: 50px;
            height: 50px;
            margin-right: 15px;
        }

        h1 {
            font-size: 2.2rem;
            margin: 0;
        }

        .tagline {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        h2 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: var(--input-background);
            color: var(--text-color);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: inline-block;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--primary-hover);
        }

        #copyResponse {
            background-color: var(--secondary-color);
        }

        #copyResponse:hover {
            background-color: var(--secondary-hover);
        }
        
        #evaluateButton {
            background-color: var(--tertiary-color);
        }

        #evaluateButton:hover {
            background-color: var(--tertiary-hover);
        }
        
        #evaluationResults {
            min-height: 300px;
            max-height: 800px;
        }

        .button-group {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .response-box {
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            color: var(--text-color);
            outline: none;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
        }
        
        .response-box p {
            margin-bottom: 1em;
        }
        
        .response-box code {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            padding: 2px 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            font-size: 0.9em;
        }
        
        [data-theme="dark"] .response-box code {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .response-box pre {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            margin-bottom: 1em;
            font-size: 0.9em;
            border: none;
        }
        
        [data-theme="dark"] .response-box pre {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .response-box pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
        }
        
        .response-box h1, .response-box h2, .response-box h3, 
        .response-box h4, .response-box h5, .response-box h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .response-box h1 {
            font-size: 1.7em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }
        
        .response-box h2 {
            font-size: 1.5em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }
        
        .response-box h3 {
            font-size: 1.3em;
        }
        
        .response-box h4 {
            font-size: 1.1em;
        }
        
        .response-box blockquote {
            border-left: 4px solid var(--border-color);
            padding-left: 12px;
            margin-left: 0;
            margin-right: 0;
            color: var(--text-secondary);
        }
        
        .response-box .boxed {
            border: 1px solid var(--border-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        [data-theme="dark"] .response-box .boxed {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .response-box ul, .response-box ol {
            padding-left: 2em;
            margin-bottom: 1em;
        }
        
        .response-box li {
            margin-bottom: 0.5em;
        }
        
        .response-box hr {
            border: 0;
            border-top: 1px solid var(--border-color);
            margin: 1.5em 0;
        }
        
        .automation-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed var(--border-color);
        }
        
        .automation-buttons, .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .secondary-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .secondary-btn:hover {
            background-color: var(--secondary-hover);
        }
        
        .secondary-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        [data-theme="dark"] .secondary-btn:disabled {
            background-color: #444444;
        }
        
        .queue-status {
            margin-left: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .prompt-clear-btn {
            background-color: #f1f1f1;
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            align-self: flex-end;
        }
        
        [data-theme="dark"] .prompt-clear-btn {
            background-color: #3c3c3e;
            color: #e8eaed;
        }
        
        .prompt-clear-btn:hover {
            background-color: #e0e0e0;
        }
        
        [data-theme="dark"] .prompt-clear-btn:hover {
            background-color: #4c4c4e;
        }
        
        .word-count {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: normal;
            margin-left: 10px;
        }
        
        .error {
            color: #d32f2f;
            background-color: rgba(211, 47, 47, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        [data-theme="dark"] .error {
            color: #f48fb1;
            background-color: rgba(244, 143, 177, 0.1);
        }

        .status {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 10px;
            font-size: 14px;
            height: 20px;
        }

        .settings-toggle {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
            padding: 0;
            margin: 0 0 20px 0;
            display: block;
            width: 100%;
            text-align: right;
        }

        .settings-card {
            display: none;
        }

        .settings-card.visible {
            display: block;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 14px;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 24px;
            transition: transform 0.3s;
        }
        
        .theme-toggle:hover {
            transform: rotate(30deg);
        }
        
        .style-guide-box {
            min-height: 100px;
        }

        .card.collapsed {
            max-height: 60px;
            overflow: hidden;
        }

        .card.collapsed .collapse-toggle {
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            background-color: var(--card-color);
            padding: 5px;
            z-index: 10;
        }

        .collapse-toggle {
            width: 100%;
            text-align: center;
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            padding: 5px;
            font-size: 14px;
            position: relative;
        }

        .collapse-toggle:hover {
            text-decoration: underline;
        }
        
        .response-separator {
            margin: 20px 0;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <button id="themeToggle" class="theme-toggle" title="Toggle dark/light mode">☀️</button>
    <header class="main-header">
        <div class="header-content">
            <img src="logo.png" alt="Cresonia AI Logo" class="logo" id="logoPlaceholder">
            <h1>Cresonia AI</h1>
        </div>
        <p class="tagline">Advanced AI Prose Generation</p>
    </header>

    <div class="card prompt-section">
        <h2>Prose Directions <span id="promptWordCount" class="word-count">(0 words)</span></h2>
        <div class="form-group">
            <textarea id="prompt" placeholder="Enter your prompt here..."></textarea>
        </div>
        <div class="form-group">
            <label for="includeProse">
                <input type="checkbox" id="includeProse" checked>
                Include previous response as prose to continue
            </label>
        </div>
        <div class="button-group">
            <button id="sendPrompt">Generate Response</button>
            <button id="clearPrompt" class="prompt-clear-btn">Clear</button>
        </div>
        <div id="promptStatus" class="status"></div>
        <div class="automation-controls">
            <div class="form-group">
                <label for="promptQueue">Queue Additional Prompts (One per line):</label>
                <textarea id="promptQueue" placeholder="Enter additional prompts here, one per line. These will be processed in sequence after the main prompt." rows="3"></textarea>
            </div>
            <div class="automation-buttons">
                <button id="processQueue" class="secondary-btn">Process Queue</button>
                <button id="stopQueue" class="secondary-btn" disabled>Stop Processing</button>
                <span id="queueStatus" class="queue-status"></span>
            </div>
        </div>
    </div>

    <div class="card prose-section">
        <h2>Prose <span id="responseWordCount" class="word-count">(0 words)</span></h2>
        <div id="response" class="response-box" contenteditable="true">Response will appear here...</div>
        <div class="button-group">
            <button id="copyResponse">Copy Response</button>
            <button id="clearResponse">Clear</button>
            <button id="evaluateButton">Evaluate Story</button>
        </div>
        <div id="responseStatus" class="status"></div>
    </div>
    
    <div class="card evaluation-section">
        <h2>Story Evaluation <span id="evaluationWordCount" class="word-count">(0 words)</span></h2>
        <div id="evaluationResults" class="response-box">Story evaluation will appear here after clicking 'Evaluate Story'...</div>
        <div class="button-group">
            <button id="copyEvaluation">Copy Evaluation</button>
            <button id="clearEvaluation">Clear</button>
        </div>
        <div id="evaluationStatus" class="status"></div>
    </div>
    
    <div id="styleGuideCard" class="card settings-section">
        <div class="sg-header">
            <h2 class="sg-title">Style Guide</h2>
        </div>
        <div class="sg-content">
            <p>Text entered here will be prepended to your prompt to guide the AI's writing style.</p>
            <textarea id="styleGuide" class="sg-textarea" placeholder="Example: Write in a professional and concise manner. Use simple language and avoid jargon."></textarea>
        </div>
    </div>

    <button id="settingsToggle" class="settings-toggle settings-section">Show Settings</button>
    
    <div id="settingsCard" class="card settings-card settings-section">
        <h2>Settings</h2>
        <div class="form-group">
            <label for="apiKey">OpenRouter API Key:</label>
            <input type="password" id="apiKey" placeholder="Enter your OpenRouter API key">
        </div>
        <div class="form-group">
            <label for="siteUrl">Your Site URL:</label>
            <input type="text" id="siteUrl" placeholder="https://your-site.com">
        </div>
        <div class="form-group">
            <label for="siteName">Your Site Name:</label>
            <input type="text" id="siteName" placeholder="Your Site Name">
        </div>
        <div class="form-group">
            <label for="model">AI Model:</label>
            <select id="model">
                <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                <option value="anthropic/claude-3-opus">Anthropic Claude 3 Opus</option>
                <option value="anthropic/claude-3.7-sonnet:beta">Anthropic Claude 3.7 Sonnet (Beta)</option>
                <option value="anthropic/claude-3.7-sonnet:thinking">Anthropic Claude 3.7 Sonnet (Thinking)</option>
                <option value="meta/llama-3-70b">Meta Llama 3 70B</option>
                <option value="google/gemini-pro">Google Gemini Pro</option>
                <option value="deepseek/deepseek-r1-zero:free">Deepseek R1 Zero</option>
                <option value="deepseek/deepseek-chat:free">Deepseek Chat (Free)</option>
                <option value="qwen/qwq-32b:free">Qwen QWQ 32B</option>
                <option value="open-r1/olympiccoder-32b:free">OlympicCoder 32B</option>
            </select>
        </div>
        <div class="form-group">
            <label for="lastSentPrompt">Last Message Sent to AI (for debugging):</label>
            <textarea id="lastSentPrompt" readonly style="min-height: 150px; background-color: var(--input-background); color: var(--text-color); font-family: monospace; font-size: 14px;"></textarea>
        </div>
        <div class="debug-buttons" style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button id="debugBtn" style="background-color: #f0ad4e;">Test API Connection</button>
            <button id="sendTestMsgBtn" style="background-color: #5bc0de;">Send Test Message</button>
            <button id="copyPromptBtn" style="background-color: #5cb85c;">Copy Last Prompt</button>
        </div>
        <button id="saveSettings">Save Settings</button>
        <div id="settingsStatus" class="status"></div>
    </div>

    <footer>
        <p>© 2025 Cresonia AI. Powered by <a href="https://openrouter.ai/" target="_blank" style="color: var(--primary-color);">OpenRouter</a>.</p>
        <p style="font-size: 12px; margin-top: 5px;">Get your API key from the <a href="https://openrouter.ai/keys" target="_blank" style="color: var(--primary-color);">OpenRouter Keys page</a> and add it in Settings.</p>
    </footer>
</div>

<script>
(function() {
    'use strict';
    
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false
            });
        } else {
            console.warn('Marked library not found, loading it now...');
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js';
            script.onload = function() {
                console.log('Marked library loaded successfully');
                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    headerIds: false,
                    mangle: false
                });
                updateWordCount();
            };
            script.onerror = function() {
                console.error('Failed to load Marked library');
            };
            document.head.appendChild(script);
        }
        
        // Function to evaluate the story
        async function evaluateStory() {
            const responseElement = document.getElementById('response');
            const evaluationElement = document.getElementById('evaluationResults');
            const statusElement = document.getElementById('evaluationStatus');

            // Get the prose content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = responseElement.innerHTML;
            const proseContent = tempDiv.textContent || tempDiv.innerText;

            if (!proseContent.trim() || 
                proseContent === 'Response will appear here...' || 
                proseContent === 'Loading...') {
                statusElement.textContent = 'Please generate prose content first';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                return;
            }

            const apiKey = localStorage.getItem('apiKey');
            if (!apiKey) {
                statusElement.textContent = 'Please enter your API key in settings';
                const settingsCard = document.getElementById('settingsCard');
                const settingsToggle = document.getElementById('settingsToggle');
                if (settingsCard && settingsToggle) {
                    settingsCard.classList.add('visible');
                    settingsToggle.textContent = 'Hide Settings';
                }
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                return;
            }

            // Build the evaluation prompt
            const evaluationPrompt = `
system:
I am a literary consultant evaluating a manuscript for readiness for professional editing or self-publishing. My goal is to provide a clear recommendation on whether the story is ready for the next stage, along with a detailed report justifying my decision and offering specific suggestions for improvement if needed.

user:
The expected genre of the story is:

Fiction

The expected style of the story is:

Contemporary

Here are other considerations or requests from the author:

Please provide detailed feedback

This is the story so far:

${proseContent}

Your evaluation should be structured as follows:

1. Readiness Verdict (Top-Line Decision):

Based on your overall assessment, provide a clear verdict:

✅ Ready for Editing/Publishing (Minor Polish Recommended): Indicate that the story is fundamentally sound and ready for professional editing or self-publishing with minor revisions.

❌ Needs Revision Before Editing/Publishing: Indicate that the story requires significant revisions before it's ready for professional editing or self-publishing.

❌ Not Ready for Editing/Publishing (Major Overhaul Needed): Indicate that the story has significant fundamental issues and requires a major overhaul before considering editing or publishing.

2. Detailed Category Assessment and Justification:

For each category below, provide a score out of 10 and a detailed explanation justifying your score and how it impacts the story's readiness for editing/publishing. Use ✅ symbol to indicate categories that are particularly strong. Use the ❌ symbol to highlight areas that are significant roadblocks to readiness.

Plot Structure & Completeness: (Score / 10) [Assess the plot's clarity, coherence, pacing, and resolution (if applicable). Is there a clear beginning, middle, and end? Does the plot hold reader interest? Is it structurally sound for the intended genre and length? Specifically address if the plot is ready for readers.]

Pacing & Momentum for Reader Engagement: (Score / 10) [Evaluate the pacing's effectiveness in keeping the reader engaged. Does it maintain momentum and build tension appropriately? Is it suitable for the target audience and genre? Is the pacing ready to keep readers turning pages?]

Character Development & Believability: (Score / 10) [Assess the depth, believability, and engagement of the characters. Are they well-defined, motivated, and relatable (or intentionally unrelatable in a compelling way)? Are the characters ready to resonate with readers?]

Worldbuilding & Setting (if applicable): (Score / 10) [Evaluate the richness, consistency, and immersiveness of the world and setting. Is it effectively conveyed and engaging? Does it serve the story? Is the worldbuilding ready to support the narrative effectively?]

Dialogue Effectiveness & Naturalness: (Score / 10) [Assess the quality and effectiveness of the dialogue. Does it sound natural? Does it reveal character and advance the plot? Is the dialogue ready to sound authentic and engaging to readers?]

Writing Quality & Clarity: (Score / 10) [Evaluate the overall quality of the writing style. Is it clear, concise, and engaging? Is the prose polished and free of distracting errors (grammar, syntax, etc.)? Is the writing ready for public consumption in terms of technical quality?]

Word Choice & Impact: (Score / 10) [Assess the vocabulary used. Is it precise, impactful, and appropriate for the tone, genre, and target audience? Is the word choice ready to create the desired effect on the reader?]

Clichés & Originality of Voice: (Score / 10) [Evaluate the presence of clichés and lack of originality. Does the story offer a fresh perspective and voice? Is the writing ready to stand out and avoid feeling derivative?]

Repetition & Redundancy: (Score / 10) [Assess any unnecessary or ineffective repetition. Is the writing concise and focused? Is the text ready to be free of distracting redundancy?]

Readability & Flow for Target Audience: (Score / 10) [Evaluate how easy and enjoyable the text is to read for the intended target audience . Is the sentence structure and language accessible and engaging for the reader you envision? Is the text ready to be easily consumed by your target reader?]

Genre Convention Adherence & Subversion (if genre is specified): (Score / 10) [If you specify a genre, evaluate how well the text meets and potentially subverts genre expectations in a successful way. Is it ready to satisfy or cleverly challenge genre readers?]

Overall Reader Experience & Impact: (Score / 10) [Based on all the above, assess the overall reader experience and potential impact of the story. Is it engaging, moving, thought-provoking, or entertaining as intended? Is the story ready to deliver a satisfying experience to readers?]

3. Appendix: Actionable Steps for Improvement (If Needed):

If the "Readiness Verdict" is "Needs Revision Before Editing/Publishing" or "Not Ready for Editing/Publishing (Major Overhaul Needed)," provide a detailed list of actionable steps with examples included that the author should take to improve the manuscript. Focus on the weakest areas identified in your category assessments. For each point, explain why it's important for readiness and how to address it concretely. Prioritize the most critical improvements needed to reach readiness. If the verdict is "Ready for Editing/Publishing (Minor Polish Recommended)," this section can offer suggestions for minor polishing during the editing phase.
`;

            statusElement.textContent = 'Generating story evaluation...';
            evaluationElement.innerHTML = 'Evaluating story... This may take a minute.';
            
            try {
                // Force the use of Deepseek Chat for evaluations
                const response = await sendAIRequest(
                    evaluationPrompt,
                    apiKey,
                    localStorage.getItem('siteUrl') || 'https://cresonia-ai.web.app',
                    localStorage.getItem('siteName') || 'Cresonia AI',
                    'deepseek/deepseek-chat:free' // Always use this model for evaluations
                );

                // Clean up the response text
                let cleanResponse = response
                    .replace(/\\boxed\{([\s\S]*?)\}/g, '$1')
                    .replace(/```markdown\s+/g, '')
                    .replace(/```(?:\w+)?\s+/g, '')
                    .replace(/```/g, '')
                    .replace(/^plaintext\s+/im, '')
                    .replace(/^```\s*plaintext\s+/im, '')
                    .replace(/^```\s*\w+\s+/gm, '');
                
                // Format with marked
                try {
                    const formattedResponse = (typeof marked !== 'undefined') 
                        ? marked.parse(cleanResponse)
                        : cleanResponse;
                    evaluationElement.innerHTML = formattedResponse;
                } catch (parseError) {
                    console.error('Error parsing markdown:', parseError);
                    evaluationElement.innerHTML = cleanResponse;
                }
                updateEvaluationWordCount();
                
                statusElement.textContent = 'Evaluation completed!';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
            } catch (error) {
                evaluationElement.innerHTML = `<div class="error">Error: ${error.message}</div>`;
                
                statusElement.textContent = 'Failed to generate evaluation';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
            }
        }
        
        // Function to copy evaluation to clipboard
        function copyEvaluation() {
            const evaluationElement = document.getElementById('evaluationResults');
            const tempElement = document.createElement('div');
            tempElement.innerHTML = evaluationElement.innerHTML;
            const evaluationText = tempElement.textContent || tempElement.innerText;
            const statusElement = document.getElementById('evaluationStatus');

            if (evaluationText && 
                evaluationText !== 'Story evaluation will appear here after clicking \'Evaluate Story\'...' && 
                evaluationText !== 'Evaluating story... This may take a minute.') {
                navigator.clipboard.writeText(evaluationText)
                    .then(() => {
                        statusElement.textContent = 'Evaluation copied to clipboard!';
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    })
                    .catch(err => {
                        console.error('Could not copy text: ', err);
                        statusElement.textContent = 'Could not copy text';
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    });
            }
        }
        
        // Function to clear evaluation
        function clearEvaluation() {
            document.getElementById('evaluationResults').innerHTML = 'Story evaluation will appear here after clicking \'Evaluate Story\'...';
            updateEvaluationWordCount();
        }
        
        // Function to update evaluation word count
        function updateEvaluationWordCount() {
            const evaluationElement = document.getElementById('evaluationResults');
            const evaluationText = evaluationElement.innerText;
            const wordCount = countWords(evaluationText);
            document.getElementById('evaluationWordCount').innerText = `(${wordCount} words)`;
        }

        // Load saved settings
        loadSettings();

        // Event listeners for buttons
        document.getElementById('saveSettings').addEventListener('click', saveSettings);
        document.getElementById('sendPrompt').addEventListener('click', sendPrompt);
        document.getElementById('copyResponse').addEventListener('click', copyResponse);
        document.getElementById('clearResponse').addEventListener('click', clearResponse);
        document.getElementById('clearPrompt').addEventListener('click', clearPromptOnly);
        
        if (document.getElementById('evaluateButton')) {
            document.getElementById('evaluateButton').addEventListener('click', evaluateStory);
        }
        if (document.getElementById('copyEvaluation')) {
            document.getElementById('copyEvaluation').addEventListener('click', copyEvaluation);
        }
        if (document.getElementById('clearEvaluation')) {
            document.getElementById('clearEvaluation').addEventListener('click', clearEvaluation);
        }
        
        // Queue variables
        let promptQueue = [];
        let isProcessingQueue = false;
        let totalQueueSize = 0;
        let isGeneratingResponse = false;
        
        // Get DOM references immediately after page load
        const processQueueBtn = document.getElementById('processQueue');
        const stopQueueBtn = document.getElementById('stopQueue');
        const queueStatusEl = document.getElementById('queueStatus');
        
        // Add event listeners directly
        if (processQueueBtn) {
            processQueueBtn.addEventListener('click', startProcessingQueue);
        } else {
            console.error("Process queue button not found");
        }
        
        if (stopQueueBtn) {
            stopQueueBtn.addEventListener('click', stopProcessingQueue);
        } else {
            console.error("Stop queue button not found");
        }
        
        // Function to start processing the queue
        function startProcessingQueue() {
            console.log("Start processing queue called");
            const queueText = document.getElementById('promptQueue').value.trim();
            if (!queueText) {
                queueStatusEl.textContent = 'Queue is empty';
                return;
            }
            
            // Split by lines and filter out empty lines
            promptQueue = queueText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            if (promptQueue.length === 0) {
                queueStatusEl.textContent = 'Queue is empty';
                return;
            }
            
            // Store the total queue size for progress tracking
            totalQueueSize = promptQueue.length;
            
            // Update UI
            processQueueBtn.disabled = true;
            stopQueueBtn.disabled = false;
            queueStatusEl.textContent = `Queue: 0/${totalQueueSize} processed`;
            isProcessingQueue = true;
            
            // Start with the first prompt if we're not already generating a response
            if (!isGeneratingResponse) {
                processNextPrompt();
            }
        }
        
        // Function to stop processing the queue
        function stopProcessingQueue() {
            promptQueue = [];
            isProcessingQueue = false;
            
            processQueueBtn.disabled = false;
            stopQueueBtn.disabled = true;
            queueStatusEl.textContent = 'Queue processing stopped';
        }
        
        // Function to process the next prompt in the queue
        async function processNextPrompt() {
            try {
                if (promptQueue.length === 0 || !isProcessingQueue) {
                    // Queue is empty or processing was stopped
                    processQueueBtn.disabled = false;
                    stopQueueBtn.disabled = true;
                    queueStatusEl.textContent = 'Queue processing completed';
                    isProcessingQueue = false;
                    return;
                }
                
                // Get the next prompt
                const nextPrompt = promptQueue.shift();
                const processed = totalQueueSize - promptQueue.length;
                
                // Update the prompt text area
                const promptEl = document.getElementById('prompt');
                if (!promptEl) {
                    console.error("Prompt element not found");
                    return;
                }
                
                promptEl.value = nextPrompt;
                updateWordCount();
                
                // Update status
                queueStatusEl.textContent = `Queue: ${processed}/${totalQueueSize} prompts processed`;
                
                // Send the prompt and wait for it to complete
                await sendPromptAsync();
                
                // No need for setTimeout here as the next prompt will be processed
                // in the finally block of sendPromptAsync when it's done
                
            } catch (err) {
                console.error("Error processing queue item:", err);
                stopProcessingQueue();
            }
        }
        
        // Modified sendPrompt function that returns a Promise
        async function sendPromptAsync() {
            const promptText = document.getElementById('prompt').value;
            const styleGuideEl = document.getElementById('styleGuide');
            const styleGuideText = styleGuideEl ? styleGuideEl.value : '';
            const includeProse = document.getElementById('includeProse').checked;
            const responseElement = document.getElementById('response');
            const statusElement = document.getElementById('promptStatus');

            if (!promptText.trim()) {
                statusElement.textContent = 'Please enter a prompt';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                return false;
            }

            const apiKey = localStorage.getItem('apiKey');
            if (!apiKey) {
                statusElement.textContent = 'Please enter your API key in settings';
                const settingsCard = document.getElementById('settingsCard');
                const settingsToggle = document.getElementById('settingsToggle');
                if (settingsCard && settingsToggle) {
                    settingsCard.classList.add('visible');
                    settingsToggle.textContent = 'Hide Settings';
                }
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                return false;
            }

            // Build the complete prompt with style guide and prose if applicable
            let completePrompt = '';
            
            // Add style guide if it exists
            if (styleGuideText.trim()) {
                completePrompt += `Style Guide: ${styleGuideText.trim()}\n\n`;
            }
            
            // Add the user's prompt
            completePrompt += promptText.trim();
            
            // Add previous response as prose if the checkbox is checked and there's a valid response
            let currentResponse = '';
            if (includeProse && 
                responseElement.innerHTML.trim() && 
                responseElement.innerHTML !== 'Response will appear here...' && 
                responseElement.innerHTML !== 'Loading...') {
                
                // Get the text content preserving line breaks
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = responseElement.innerHTML;
                currentResponse = tempDiv.textContent || tempDiv.innerText;
                
                completePrompt += `\n\nProse to continue: ${currentResponse.trim()}`;
            }
            
            // Store the complete prompt for debugging
            localStorage.setItem('lastSentPrompt', completePrompt);
            // Update the debug textarea if settings are visible
            if (document.getElementById('lastSentPrompt')) {
                document.getElementById('lastSentPrompt').value = completePrompt;
            }

            statusElement.textContent = 'Generating response...';
            isGeneratingResponse = true;
            
            // Save current response if it's not empty/default
            // Save current response if it's not empty/default
            let isDefaultResponse = responseElement.innerHTML === 'Response will appear here...' || 
                                   responseElement.innerHTML === 'Loading...';
            
            if (!isDefaultResponse) {
                // Create a separator and add loading placeholder with an ID
                responseElement.innerHTML += '<div class="response-separator"></div><div id="loading-placeholder">Loading...</div>';
            } else {
                // Just set loading placeholder if there's no existing content
                responseElement.innerHTML = '<div id="loading-placeholder">Loading...</div>';
            }
            updateWordCount();

            try {
                const response = await sendAIRequest(
                    completePrompt,
                    apiKey,
                    localStorage.getItem('siteUrl') || 'https://cresonia-ai.web.app',
                    localStorage.getItem('siteName') || 'Cresonia AI',
                    localStorage.getItem('model') || 'openai/gpt-4o'
                );

                // Clean up the text to remove markdown code blocks and any text prefixes
                let cleanResponse = response
                    .replace(/\\boxed\{([\s\S]*?)\}/g, '$1') // Remove boxed formatting
                    .replace(/```markdown\s+/g, '') // Remove markdown code block start
                    .replace(/```(?:\w+)?\s+/g, '') // Remove any code block start with language
                    .replace(/```/g, '') // Remove any remaining code block markers
                    .replace(/^plaintext\s+/im, '') // Remove plaintext prefix
                    .replace(/^```\s*plaintext\s+/im, '') // Remove plaintext code block
                    .replace(/^```\s*\w+\s+/gm, ''); // Remove any language-specific code block starts
                
                // Apply Markdown parsing to the cleaned text
                try {
                    const formattedResponse = (typeof marked !== 'undefined') 
                        ? marked.parse(cleanResponse)
                        : cleanResponse;
                    
                    // Replace the loading placeholder with the formatted response
                    const loadingPlaceholder = document.getElementById('loading-placeholder');
                    if (loadingPlaceholder) {
                        // Replace only the loading placeholder with the new content
                        loadingPlaceholder.outerHTML = formattedResponse;
                    } else {
                        // Fallback in case the placeholder isn't found
                        responseElement.innerHTML = formattedResponse;
                    }
                } catch (parseError) {
                    console.error('Error parsing markdown:', parseError);
                    responseElement.innerHTML = cleanResponse;
                }
                
                updateWordCount();
                
                statusElement.textContent = 'Response generated successfully!';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                
                return true;
            } catch (error) {
                const loadingPlaceholder = document.getElementById('loading-placeholder');
                if (loadingPlaceholder) {
                    // Replace only the loading placeholder with the error message
                    loadingPlaceholder.outerHTML = `<div class="error">Error: ${error.message}</div>`;
                } else {
                    // Fallback in case the placeholder isn't found
                    responseElement.innerHTML = `<div class="error">Error: ${error.message}</div>`;
                }
                updateWordCount();
                
                statusElement.textContent = 'Failed to get response';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 3000);
                
                return false;
            } finally {
                isGeneratingResponse = false;
                
                // If queue processing is active, process the next prompt
                if (isProcessingQueue && promptQueue.length > 0) {
                    // Small delay to ensure UI updates before next processing
                    setTimeout(processNextPrompt, 500);
                }
            }
        }

        // Original sendPrompt function now uses the async version
        function sendPrompt() {
            sendPromptAsync(); // We don't need to await here for the original function
        }
        
        // Function to clear the prompt only
        function clearPromptOnly() {
            document.getElementById('prompt').value = '';
            updateWordCount();
        }
        
        // Function to clear response
        function clearResponse() {
            document.getElementById('response').innerHTML = 'Response will appear here...';
            updateWordCount();
        }

        // Function to toggle between light and dark themes
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            updateThemeToggleIcon(newTheme);
        }
        
        // Update theme toggle icon based on current theme
        function updateThemeToggleIcon(theme) {
            const themeToggle = document.getElementById('themeToggle');
            themeToggle.innerHTML = theme === 'dark' ? '🌙' : '☀️';
            themeToggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
        }

        // Function to load settings from localStorage
        function loadSettings() {
            const apiKey = localStorage.getItem('apiKey') || '';
            const siteUrl = localStorage.getItem('siteUrl') || '';
            const siteName = localStorage.getItem('siteName') || '';
            const model = localStorage.getItem('model') || 'openai/gpt-4o';
            const styleGuide = localStorage.getItem('styleGuide') || '';
            const lastSentPrompt = localStorage.getItem('lastSentPrompt') || 'No messages sent yet.';
            const savedPrompt = localStorage.getItem('savedPrompt') || '';
            const savedQueue = localStorage.getItem('savedQueue') || '';

            document.getElementById('apiKey').value = apiKey;
            document.getElementById('siteUrl').value = siteUrl;
            document.getElementById('siteName').value = siteName;
            document.getElementById('model').value = model;
            document.getElementById('prompt').value = savedPrompt;
            document.getElementById('promptQueue').value = savedQueue;
            
            // Style guide element might be using a different structure
            const styleGuideEl = document.getElementById('styleGuide');
            if (styleGuideEl) {
                styleGuideEl.value = styleGuide;
            }
            
            const lastSentPromptEl = document.getElementById('lastSentPrompt');
            if (lastSentPromptEl) {
                lastSentPromptEl.value = lastSentPrompt;
            }
            
            // Update word counts
            updateWordCount();
        }

        // Function to save settings to localStorage
        function saveSettings() {
            const apiKey = document.getElementById('apiKey').value;
            const siteUrl = document.getElementById('siteUrl').value;
            const siteName = document.getElementById('siteName').value;
            const model = document.getElementById('model').value;
            const styleGuideEl = document.getElementById('styleGuide');
            const styleGuide = styleGuideEl ? styleGuideEl.value : '';
            
            // Always get current prompt and queue
            const promptEl = document.getElementById('prompt');
            const queueEl = document.getElementById('promptQueue');
            const promptText = promptEl ? promptEl.value : '';
            const queueText = queueEl ? queueEl.value : '';

            localStorage.setItem('apiKey', apiKey);
            localStorage.setItem('siteUrl', siteUrl);
            localStorage.setItem('siteName', siteName);
            localStorage.setItem('model', model);
            localStorage.setItem('styleGuide', styleGuide);
            localStorage.setItem('savedPrompt', promptText);
            localStorage.setItem('savedQueue', queueText);

            const status = document.getElementById('settingsStatus');
            if (status) {
                status.textContent = 'Settings saved!';
                setTimeout(() => {
                    status.textContent = '';
                }, 3000);
            }
        }

        // Function to copy response to clipboard
        function copyResponse() {
            const responseElement = document.getElementById('response');
            // Create a temporary element to extract text content without HTML formatting
            const tempElement = document.createElement('div');
            tempElement.innerHTML = responseElement.innerHTML;
            const responseText = tempElement.textContent || tempElement.innerText;
            const statusElement = document.getElementById('responseStatus');

            if (responseText && responseText !== 'Response will appear here...' && responseText !== 'Loading...') {
                navigator.clipboard.writeText(responseText)
                    .then(() => {
                        statusElement.textContent = 'Response copied to clipboard!';
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    })
                    .catch(err => {
                        console.error('Could not copy text: ', err);
                        statusElement.textContent = 'Could not copy text';
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    });
            }
        }
        
        // Function to count words in text, handling both HTML and plain text
        function countWords(text) {
            // If it's HTML content, extract the text
            if (text.includes('<') && text.includes('>')) {
                const tempElement = document.createElement('div');
                tempElement.innerHTML = text;
                text = tempElement.textContent || tempElement.innerText;
            }
            
            text = text.trim();
            if (!text) return 0;
            return text.split(/\s+/).length;
        }
        
        // Function to update all word counts
        function updateWordCount() {
            const promptText = document.getElementById('prompt').value;
            const responseElement = document.getElementById('response');
            const responseText = responseElement.innerHTML;
            const evaluationElement = document.getElementById('evaluationResults');
            const evaluationText = evaluationElement.innerHTML;
            
            const promptWordCount = countWords(promptText);
            const responseWordCount = countWords(responseText);
            const evaluationWordCount = countWords(evaluationText);
            
            document.getElementById('promptWordCount').innerText = `(${promptWordCount} words)`;
            document.getElementById('responseWordCount').innerText = `(${responseWordCount} words)`;
            document.getElementById('evaluationWordCount').innerText = `(${evaluationWordCount} words)`;
        }

        // Function to send request to OpenRouter API
        async function sendAIRequest(prompt, apiKey, siteUrl, siteName, model, isDebugMode = false) {
            try {
                console.log('Sending request to OpenRouter API:', {
                    model: model,
                    prompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : '')
                });
                
                const requestBody = {
                    model: model,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                };
                
                console.log('Full request body:', JSON.stringify(requestBody));
                
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'HTTP-Referer': siteUrl,
                        'X-Title': siteName
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                
                // Get the raw response text for debugging
                const responseText = await response.text();
                console.log('Raw response:', responseText);
                
                // Try to parse the response as JSON
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('Error parsing JSON response:', e);
                    throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
                }
                
                if (!response.ok) {
                    const errorMessage = data.error?.message || `HTTP error! status: ${response.status}`;
                    console.error('API error:', errorMessage);
                    throw new Error(errorMessage);
                }
                
                // Validate the response structure
                if (!data || !data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
                    console.error('Unexpected API response format:', data);
                    throw new Error('Received an invalid response from the API');
                }
                
                const firstChoice = data.choices[0];
                if (!firstChoice.message || typeof firstChoice.message.content !== 'string') {
                    console.error('Response missing expected content:', firstChoice);
                    throw new Error('Response did not contain the expected content');
                }
                
                console.log('Successfully received response');
                return firstChoice.message.content;
            } catch (error) {
                console.error('Error in sendAIRequest:', error);
                throw error;
            }
        }

        // Function to create a placeholder logo
        function createPlaceholderLogo() {
            const canvas = document.createElement('canvas');
            const size = 100;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#4285f4';
            ctx.fillRect(0, 0, size, size);
            
            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('C', size/2, size/2);
            
            return canvas.toDataURL();
        }
        
        // Set up the logo placeholder
        const logoPlaceholder = document.getElementById('logoPlaceholder');
        if (logoPlaceholder) {
            logoPlaceholder.onerror = function() {
                this.src = createPlaceholderLogo();
                this.onerror = null;
            };
        }

        // Set theme from localStorage or default to light
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeToggleIcon(savedTheme);

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', toggleTheme);
        }

        // Toggle settings visibility
        const settingsToggle = document.getElementById('settingsToggle');
        const settingsCard = document.getElementById('settingsCard');
        
        if (settingsToggle && settingsCard) {
            settingsToggle.addEventListener('click', function() {
                const isVisible = settingsCard.classList.contains('visible');
                if (isVisible) {
                    settingsCard.classList.remove('visible');
                    settingsToggle.textContent = 'Show Settings';
                } else {
                    // Update the last sent prompt when opening settings
                    const lastSentPrompt = localStorage.getItem('lastSentPrompt') || 'No messages sent yet.';
                    const lastSentPromptEl = document.getElementById('lastSentPrompt');
                    if (lastSentPromptEl) {
                        lastSentPromptEl.value = lastSentPrompt;
                    }
                    
                    settingsCard.classList.add('visible');
                    settingsToggle.textContent = 'Hide Settings';
                }
            });
        }
    });
})();
</script>
</body>
</html>
