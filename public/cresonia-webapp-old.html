<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cresonia AI</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>C</text></svg>" type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <script>
        // Configure marked.js for better rendering
        document.addEventListener('DOMContentLoaded', function() {
            marked.setOptions({
                breaks: true,        // Convert line breaks to <br>
                gfm: true,           // GitHub flavored markdown
                headerIds: false,    // Don't add IDs to headers
                mangle: false        // Don't mangle email addresses
            });
        });
    </script>
    <style>
        :root {
            /* Light Theme (default) */
            --primary-color: #4285f4;
            --primary-hover: #3367d6;
            --secondary-color: #34a853;
            --secondary-hover: #2d9249;
            --background-color: #f5f5f5;
            --card-color: #fff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #e0e0e0;
            --input-background: #fff;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        [data-theme="dark"] {
            --primary-color: #5f9efa;
            --primary-hover: #4285f4;
            --secondary-color: #46c266;
            --secondary-hover: #34a853;
            --background-color: #202124;
            --card-color: #2c2c2e;
            --text-color: #e8eaed;
            --text-secondary: #9aa0a6;
            --border-color: #3c4043;
            --input-background: #3c3c3e;
            --shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        /* Suppress favicon 404 error */
        link[rel="icon"][href="favicon.ico"] {
            display: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo {
            width: 50px;
            height: 50px;
            margin-right: 15px;
        }

        h1 {
            font-size: 2.2rem;
            margin: 0;
        }

        .tagline {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        h2 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: var(--input-background);
            color: var(--text-color);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: inline-block;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--primary-hover);
        }

        #copyResponse {
            background-color: var(--secondary-color);
        }

        #copyResponse:hover {
            background-color: var(--secondary-hover);
        }

        .button-group {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .response-box {
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            color: var(--text-color);
            outline: none;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
        }
        
        .response-box p {
            margin-bottom: 1em;
        }
        
        .response-box code {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            padding: 2px 4px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            font-size: 0.9em;
        }
        
        [data-theme="dark"] .response-box code {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .response-box pre {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            margin-bottom: 1em;
            font-size: 0.9em;
            border: none;
        }
        
        [data-theme="dark"] .response-box pre {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .response-box pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
        }
        
        .response-box h1, .response-box h2, .response-box h3, 
        .response-box h4, .response-box h5, .response-box h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .response-box h1 {
            font-size: 1.7em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }
        
        .response-box h2 {
            font-size: 1.5em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }
        
        .response-box h3 {
            font-size: 1.3em;
        }
        
        .response-box h4 {
            font-size: 1.1em;
        }
        
        .response-box blockquote {
            border-left: 4px solid var(--border-color);
            padding-left: 12px;
            margin-left: 0;
            margin-right: 0;
            color: var(--text-secondary);
        }
        
        .response-box .boxed {
            border: 1px solid var(--border-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        [data-theme="dark"] .response-box .boxed {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .response-box ul, .response-box ol {
            padding-left: 2em;
            margin-bottom: 1em;
        }
        
        .response-box li {
            margin-bottom: 0.5em;
        }
        
        .response-box hr {
            border: 0;
            border-top: 1px solid var(--border-color);
            margin: 1.5em 0;
        }
        
        /* Automation controls */
        .automation-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed var(--border-color);
        }
        
        .automation-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .secondary-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .secondary-btn:hover {
            background-color: var(--secondary-hover);
        }
        
        .secondary-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        [data-theme="dark"] .secondary-btn:disabled {
            background-color: #444444;
        }
        
        .queue-status {
            margin-left: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .prompt-clear-btn {
            background-color: #f1f1f1;
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            align-self: flex-end;
        }
        
        [data-theme="dark"] .prompt-clear-btn {
            background-color: #3c3c3e;
            color: #e8eaed;
        }
        
        .prompt-clear-btn:hover {
            background-color: #e0e0e0;
        }
        
        [data-theme="dark"] .prompt-clear-btn:hover {
            background-color: #4c4c4e;
        }
        
        .word-count {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: normal;
            margin-left: 10px;
        }
        
        .error {
            color: #d32f2f;
            background-color: rgba(211, 47, 47, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        [data-theme="dark"] .error {
            color: #f48fb1;
            background-color: rgba(244, 143, 177, 0.1);
        }

        .status {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 10px;
            font-size: 14px;
            height: 20px;
        }

        .settings-toggle {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
            padding: 0;
            margin: 0 0 20px 0;
            display: block;
            width: 100%;
            text-align: right;
        }

        .settings-card {
            display: none;
        }

        .settings-card.visible {
            display: block;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Theme toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 24px;
            transition: transform 0.3s;
        }
        
        .theme-toggle:hover {
            transform: rotate(30deg);
        }
        
        .style-guide-box {
            min-height: 100px;
        }

        .card.collapsed {
            max-height: 60px;
            overflow: hidden;
        }

        .card.collapsed .collapse-toggle {
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            background-color: var(--card-color);
            padding: 5px;
            z-index: 10;
        }

        .collapse-toggle {
            width: 100%;
            text-align: center;
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            padding: 5px;
            font-size: 14px;
            position: relative;
        }

        .collapse-toggle:hover {
            text-decoration: underline;
        }
        
        .response-separator {
            margin: 20px 0;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button id="themeToggle" class="theme-toggle" title="Toggle dark/light mode">‚òÄÔ∏è</button>
        <header>
            <div class="header-content">
                <img src="logo.png" alt="Cresonia AI Logo" class="logo" id="logoPlaceholder">
                <h1>Cresonia AI</h1>
            </div>
            <p class="tagline">Advanced AI Prose Generation</p>
        </header>

        <div class="card">
            <h2>Prose Directions <span id="promptWordCount" class="word-count">(0 words)</span></h2>
            <div class="form-group">
                <textarea id="prompt" placeholder="Enter your prompt here..."></textarea>
            </div>
            <div class="form-group">
                <label for="includeProse">
                    <input type="checkbox" id="includeProse" checked>
                    Include previous response as prose to continue
                </label>
            </div>
            <div class="button-group">
                <button id="sendPrompt">Generate Response</button>
                <button id="clearPrompt" class="prompt-clear-btn">Clear</button>
            </div>
            <div id="promptStatus" class="status"></div>
            <div class="automation-controls">
                <div class="form-group">
                    <label for="promptQueue">Queue Additional Prompts (One per line):</label>
                    <textarea id="promptQueue" placeholder="Enter additional prompts here, one per line. These will be processed in sequence after the main prompt." rows="3"></textarea>
                </div>
                <div class="automation-buttons">
                    <button id="processQueue" class="secondary-btn">Process Queue</button>
                    <button id="stopQueue" class="secondary-btn" disabled>Stop Processing</button>
                    <span id="queueStatus" class="queue-status"></span>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Prose <span id="responseWordCount" class="word-count">(0 words)</span></h2>
            <div id="response" class="response-box" contenteditable="true">Response will appear here...</div>
            <div class="button-group">
                <button id="copyResponse">Copy Response</button>
                <button id="clearResponse">Clear</button>
            </div>
            <div id="responseStatus" class="status"></div>
        </div>
        
        <div id="styleGuideCard">
            <div class="sg-header">
                <h2 class="sg-title">Style Guide</h2>
            </div>
            <div class="sg-content">
                <p>Text entered here will be prepended to your prompt to guide the AI's writing style.</p>
                <textarea id="styleGuide" class="sg-textarea" placeholder="Example: Write in a professional and concise manner. Use simple language and avoid jargon."></textarea>
            </div>
        </div>

        <button id="settingsToggle" class="settings-toggle">Show Settings</button>
        
        <div id="settingsCard" class="card settings-card">
            <h2>Settings</h2>
            <div class="form-group">
                <label for="apiKey">OpenRouter API Key:</label>
                <input type="password" id="apiKey" placeholder="Enter your OpenRouter API key">
            </div>
            <div class="form-group">
                <label for="siteUrl">Your Site URL:</label>
                <input type="text" id="siteUrl" placeholder="https://your-site.com">
            </div>
            <div class="form-group">
                <label for="siteName">Your Site Name:</label>
                <input type="text" id="siteName" placeholder="Your Site Name">
            </div>
            <div class="form-group">
                <label for="model">AI Model:</label>
                <select id="model">
                    <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                    <option value="anthropic/claude-3-opus">Anthropic Claude 3 Opus</option>
                    <option value="anthropic/claude-3.7-sonnet:beta">Anthropic Claude 3.7 Sonnet (Beta)</option>
                    <option value="anthropic/claude-3.7-sonnet:thinking">Anthropic Claude 3.7 Sonnet (Thinking)</option>
                    <option value="meta/llama-3-70b">Meta Llama 3 70B</option>
                    <option value="google/gemini-pro">Google Gemini Pro</option>
                    <option value="deepseek/deepseek-r1-zero:free">Deepseek R1 Zero</option>
                    <option value="qwen/qwq-32b:free">Qwen QWQ 32B</option>
                    <option value="open-r1/olympiccoder-32b:free">OlympicCoder 32B</option>
                </select>
            </div>
            <div class="form-group">
                <label for="lastSentPrompt">Last Message Sent to AI (for debugging):</label>
                <textarea id="lastSentPrompt" readonly style="min-height: 150px; background-color: var(--input-background); color: var(--text-color); font-family: monospace; font-size: 14px;"></textarea>
            </div>
            <div class="debug-buttons" style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button id="debugBtn" style="background-color: #f0ad4e;">Test API Connection</button>
                <button id="sendTestMsgBtn" style="background-color: #5bc0de;">Send Test Message</button>
                <button id="copyPromptBtn" style="background-color: #5cb85c;">Copy Last Prompt</button>
            </div>
            <button id="saveSettings">Save Settings</button>
            <div id="settingsStatus" class="status"></div>
        </div>

        <footer>
            <p>¬© 2025 Cresonia AI. Powered by <a href="https://openrouter.ai/" target="_blank" style="color: var(--primary-color);">OpenRouter</a>.</p>
            <p style="font-size: 12px; margin-top: 5px;">Get your API key from the <a href="https://openrouter.ai/keys" target="_blank" style="color: var(--primary-color);">OpenRouter Keys page</a> and add it in Settings.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Function to update word counts
            function updateWordCount() {
                const promptText = document.getElementById('prompt').value;
                const responseElement = document.getElementById('response');
                const responseText = responseElement.innerHTML;
                
                const promptWordCount = countWords(promptText);
                const responseWordCount = countWords(responseText);
                
                document.getElementById('promptWordCount').innerText = `(${promptWordCount} words)`;
                document.getElementById('responseWordCount').innerText = `(${responseWordCount} words)`;
            }
            
            // Set up Marked.js options for better rendering
            marked.setOptions({
                breaks: true,  // Add line breaks without needing two spaces
                gfm: true,     // Enable GitHub Flavored Markdown
                headerIds: false, // Don't add IDs to headers
                mangle: false   // Don't mangle email addresses
            });
            
            const logoPlaceholder = document.getElementById('logoPlaceholder');
            logoPlaceholder.onerror = function() {
                this.src = createPlaceholderLogo();
                this.onerror = null;
            };

            // Set theme from localStorage or default to light
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeToggleIcon(savedTheme);

            // Theme toggle functionality
            const themeToggle = document.getElementById('themeToggle');
            themeToggle.addEventListener('click', toggleTheme);

            // Style Guide collapse functionality
            const styleGuideCard = document.getElementById('styleGuideCard');
            const collapseStyleGuideBtn = document.getElementById('collapseStyleGuide');
            
            if (styleGuideCard && collapseStyleGuideBtn) {
                collapseStyleGuideBtn.addEventListener('click', function(e) {
                    e.preventDefault(); // Prevent default button behavior
                    console.log('Toggle button clicked');
                    
                    if (styleGuideCard.classList.contains('collapsed')) {
                        console.log('Expanding');
                        styleGuideCard.classList.remove('collapsed');
                        collapseStyleGuideBtn.textContent = 'Collapse';
                    } else {
                        console.log('Collapsing');
                        styleGuideCard.classList.add('collapsed');
                        collapseStyleGuideBtn.textContent = 'Expand';
                    }
                });
                
                // Make sure the button is visible and clickable
                collapseStyleGuideBtn.style.zIndex = "100";
            } else {
                console.error('Style guide card or collapse button not found');
            }

            // Toggle settings visibility
            const settingsToggle = document.getElementById('settingsToggle');
            const settingsCard = document.getElementById('settingsCard');
            
            if (settingsToggle && settingsCard) {
                settingsToggle.addEventListener('click', function() {
                    const isVisible = settingsCard.classList.contains('visible');
                    if (isVisible) {
                        settingsCard.classList.remove('visible');
                        settingsToggle.textContent = 'Show Settings';
                    } else {
                        // Update the last sent prompt when opening settings
                        const lastSentPrompt = localStorage.getItem('lastSentPrompt') || 'No messages sent yet.';
                        const lastSentPromptEl = document.getElementById('lastSentPrompt');
                        if (lastSentPromptEl) {
                            lastSentPromptEl.value = lastSentPrompt;
                        }
                        
                        settingsCard.classList.add('visible');
                        settingsToggle.textContent = 'Hide Settings';
                    }
                });
            }

            // Load saved settings
            loadSettings();

            // Event listeners for buttons
            document.getElementById('saveSettings').addEventListener('click', saveSettings);
            document.getElementById('sendPrompt').addEventListener('click', sendPrompt);
            document.getElementById('copyResponse').addEventListener('click', copyResponse);
            document.getElementById('clearResponse').addEventListener('click', clearResponse);
            document.getElementById('clearPrompt').addEventListener('click', clearPromptOnly);
            
            // --- IMPROVED QUEUE PROCESSING SYSTEM ---
            // Queue variables
            let promptQueue = [];
            let isProcessingQueue = false;
            let totalQueueSize = 0;
            let isGeneratingResponse = false;
            
            // Get DOM references immediately after page load
            const processQueueBtn = document.getElementById('processQueue');
            const stopQueueBtn = document.getElementById('stopQueue');
            const queueStatusEl = document.getElementById('queueStatus');
            
            // Add event listeners directly
            if (processQueueBtn) {
                processQueueBtn.addEventListener('click', startProcessingQueue);
            } else {
                console.error("Process queue button not found");
            }
            
            if (stopQueueBtn) {
                stopQueueBtn.addEventListener('click', stopProcessingQueue);
            } else {
                console.error("Stop queue button not found");
            }
            
            // Function to start processing the queue
            function startProcessingQueue() {
                console.log("Start processing queue called");
                const queueText = document.getElementById('promptQueue').value.trim();
                if (!queueText) {
                    queueStatusEl.textContent = 'Queue is empty';
                    return;
                }
                
                // Split by lines and filter out empty lines
                promptQueue = queueText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                if (promptQueue.length === 0) {
                    queueStatusEl.textContent = 'Queue is empty';
                    return;
                }
                
                // Store the total queue size for progress tracking
                totalQueueSize = promptQueue.length;
                
                // Update UI
                processQueueBtn.disabled = true;
                stopQueueBtn.disabled = false;
                queueStatusEl.textContent = `Queue: 0/${totalQueueSize} processed`;
                isProcessingQueue = true;
                
                // Start with the first prompt if we're not already generating a response
                if (!isGeneratingResponse) {
                    processNextPrompt();
                }
            }
            
            // Function to stop processing the queue
            function stopProcessingQueue() {
                promptQueue = [];
                isProcessingQueue = false;
                
                processQueueBtn.disabled = false;
                stopQueueBtn.disabled = true;
                queueStatusEl.textContent = 'Queue processing stopped';
            }
            
            // Function to process the next prompt in the queue
            async function processNextPrompt() {
                try {
                    if (promptQueue.length === 0 || !isProcessingQueue) {
                        // Queue is empty or processing was stopped
                        processQueueBtn.disabled = false;
                        stopQueueBtn.disabled = true;
                        queueStatusEl.textContent = 'Queue processing completed';
                        isProcessingQueue = false;
                        return;
                    }
                    
                    // Get the next prompt
                    const nextPrompt = promptQueue.shift();
                    const processed = totalQueueSize - promptQueue.length;
                    
                    // Update the prompt text area
                    const promptEl = document.getElementById('prompt');
                    if (!promptEl) {
                        console.error("Prompt element not found");
                        return;
                    }
                    
                    promptEl.value = nextPrompt;
                    updateWordCount();
                    
                    // Update status
                    queueStatusEl.textContent = `Queue: ${processed}/${totalQueueSize} prompts processed`;
                    
                    // Send the prompt and wait for it to complete
                    await sendPromptAsync();
                    
                    // No need for setTimeout here as the next prompt will be processed
                    // in the finally block of sendPromptAsync when it's done
                    
                } catch (err) {
                    console.error("Error processing queue item:", err);
                    stopProcessingQueue();
                }
            }
            
            // Modified sendPrompt function that returns a Promise
            async function sendPromptAsync() {
                const promptText = document.getElementById('prompt').value;
                const styleGuideEl = document.getElementById('styleGuide');
                const styleGuideText = styleGuideEl ? styleGuideEl.value : '';
                const includeProse = document.getElementById('includeProse').checked;
                const responseElement = document.getElementById('response');
                const statusElement = document.getElementById('promptStatus');

                if (!promptText.trim()) {
                    statusElement.textContent = 'Please enter a prompt';
                    setTimeout(() => {
                        statusElement.textContent = '';
                    }, 3000);
                    return false;
                }

                const apiKey = localStorage.getItem('apiKey');
                if (!apiKey) {
                    statusElement.textContent = 'Please enter your API key in settings';
                    const settingsCard = document.getElementById('settingsCard');
                    const settingsToggle = document.getElementById('settingsToggle');
                    if (settingsCard && settingsToggle) {
                        settingsCard.classList.add('visible');
                        settingsToggle.textContent = 'Hide Settings';
                    }
                    setTimeout(() => {
                        statusElement.textContent = '';
                    }, 3000);
                    return false;
                }

                // Build the complete prompt with style guide and prose if applicable
                let completePrompt = '';
                
                // Add style guide if it exists
                if (styleGuideText.trim()) {
                    completePrompt += `Style Guide: ${styleGuideText.trim()}\n\n`;
                }
                
                // Add the user's prompt
                completePrompt += promptText.trim();
                
                // Add previous response as prose if the checkbox is checked and there's a valid response
                let currentResponse = '';
                if (includeProse && 
                    responseElement.innerHTML.trim() && 
                    responseElement.innerHTML !== 'Response will appear here...' && 
                    responseElement.innerHTML !== 'Loading...') {
                    
                    // Get the text content preserving line breaks
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = responseElement.innerHTML;
                    currentResponse = tempDiv.textContent || tempDiv.innerText;
                    
                    completePrompt += `\n\nProse to continue: ${currentResponse.trim()}`;
                }
                
                // Store the complete prompt for debugging
                localStorage.setItem('lastSentPrompt', completePrompt);
                // Update the debug textarea if settings are visible
                if (document.getElementById('lastSentPrompt')) {
                    document.getElementById('lastSentPrompt').value = completePrompt;
                }

                statusElement.textContent = 'Generating response...';
                isGeneratingResponse = true;
                
                // Save current response if it's not empty/default
                let isDefaultResponse = responseElement.innerHTML === 'Response will appear here...' || 
                                       responseElement.innerHTML === 'Loading...';
                
                if (!isDefaultResponse) {
                    // Create a separator and add loading placeholder with an ID
                    responseElement.innerHTML += '<div class="response-separator"></div><div id="loading-placeholder">Loading...</div>';
                } else {
                    // Just set loading placeholder if there's no existing content
                    responseElement.innerHTML = '<div id="loading-placeholder">Loading...</div>';
                }
                updateWordCount();

                try {
                    const response = await sendAIRequest(
                        completePrompt,
                        apiKey,
                        localStorage.getItem('siteUrl') || 'https://cresonia-ai.web.app',
                        localStorage.getItem('siteName') || 'Cresonia AI',
                        localStorage.getItem('model') || 'openai/gpt-4o'
                    );

                    // Clean up the text to remove markdown code blocks and any text prefixes
                    let cleanResponse = response
                        .replace(/\\boxed\{([\s\S]*?)\}/g, '$1') // Remove boxed formatting
                        .replace(/```markdown\s+/g, '') // Remove markdown code block start
                        .replace(/```(?:\w+)?\s+/g, '') // Remove any code block start with language
                        .replace(/```/g, '') // Remove any remaining code block markers
                        .replace(/^plaintext\s+/im, '') // Remove plaintext prefix
                        .replace(/^```\s*plaintext\s+/im, '') // Remove plaintext code block
                        .replace(/^```\s*\w+\s+/gm, ''); // Remove any language-specific code block starts
                    
                    // Apply Markdown parsing to the cleaned text
                    const formattedResponse = marked.parse(cleanResponse);
                    
                    // Replace the loading placeholder with the formatted response
                    const loadingPlaceholder = document.getElementById('loading-placeholder');
                    if (loadingPlaceholder) {
                        // Replace only the loading placeholder with the new content
                        loadingPlaceholder.outerHTML = formattedResponse;
                    } else {
                        // Fallback in case the placeholder isn't found
                        responseElement.innerHTML = formattedResponse;
                    }
                    
                    updateWordCount();
                    
                    statusElement.textContent = 'Response generated successfully!';
                    setTimeout(() => {
                        statusElement.textContent = '';
                    }, 3000);
                    
                    return true;
                } catch (error) {
                    const loadingPlaceholder = document.getElementById('loading-placeholder');
                    if (loadingPlaceholder) {
                        // Replace only the loading placeholder with the error message
                        loadingPlaceholder.outerHTML = `<div class="error">Error: ${error.message}</div>`;
                    } else {
                        // Fallback in case the placeholder isn't found
                        responseElement.innerHTML = `<div class="error">Error: ${error.message}</div>`;
                    }
                    updateWordCount();
                    
                    statusElement.textContent = 'Failed to get response';
                    setTimeout(() => {
                        statusElement.textContent = '';
                    }, 3000);
                    
                    return false;
                } finally {
                    isGeneratingResponse = false;
                    
                    // If queue processing is active, process the next prompt
                    if (isProcessingQueue && promptQueue.length > 0) {
                        // Small delay to ensure UI updates before next processing
                        setTimeout(processNextPrompt, 500);
                    }
                }
            }

            // Original sendPrompt function now uses the async version
            function sendPrompt() {
                sendPromptAsync(); // We don't need to await here for the original function
            }
            
            // Function to clear the prompt only
            function clearPromptOnly() {
                document.getElementById('prompt').value = '';
                updateWordCount();
            }
            
            // Function to clear response
            function clearResponse() {
                document.getElementById('response').innerHTML = 'Response will appear here...';
                updateWordCount();
            }

            // Function to toggle between light and dark themes
            function toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                updateThemeToggleIcon(newTheme);
            }
            
            // Update theme toggle icon based on current theme
            function updateThemeToggleIcon(theme) {
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.innerHTML = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
                themeToggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
            }

            // Function to load settings from localStorage
            function loadSettings() {
                const apiKey = localStorage.getItem('apiKey') || '';
                const siteUrl = localStorage.getItem('siteUrl') || '';
                const siteName = localStorage.getItem('siteName') || '';
                const model = localStorage.getItem('model') || 'openai/gpt-4o';
                const styleGuide = localStorage.getItem('styleGuide') || '';
                const lastSentPrompt = localStorage.getItem('lastSentPrompt') || 'No messages sent yet.';

                document.getElementById('apiKey').value = apiKey;
                document.getElementById('siteUrl').value = siteUrl;
                document.getElementById('siteName').value = siteName;
                document.getElementById('model').value = model;
                
                // Style guide element might be using a different structure
                const styleGuideEl = document.getElementById('styleGuide');
                if (styleGuideEl) {
                    styleGuideEl.value = styleGuide;
                }
                
                const lastSentPromptEl = document.getElementById('lastSentPrompt');
                if (lastSentPromptEl) {
                    lastSentPromptEl.value = lastSentPrompt;
                }
            }

            // Function to save settings to localStorage
            function saveSettings() {
                const apiKey = document.getElementById('apiKey').value;
                const siteUrl = document.getElementById('siteUrl').value;
                const siteName = document.getElementById('siteName').value;
                const model = document.getElementById('model').value;
                const styleGuideEl = document.getElementById('styleGuide');
                const styleGuide = styleGuideEl ? styleGuideEl.value : '';

                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('siteUrl', siteUrl);
                localStorage.setItem('siteName', siteName);
                localStorage.setItem('model', model);
                localStorage.setItem('styleGuide', styleGuide);

                const status = document.getElementById('settingsStatus');
                if (status) {
                    status.textContent = 'Settings saved!';
                    setTimeout(() => {
                        status.textContent = '';
                    }, 3000);
                }
            }

            // Function to copy response to clipboard
            function copyResponse() {
                const responseElement = document.getElementById('response');
                // Create a temporary element to extract text content without HTML formatting
                const tempElement = document.createElement('div');
                tempElement.innerHTML = responseElement.innerHTML;
                const responseText = tempElement.textContent || tempElement.innerText;
                const statusElement = document.getElementById('responseStatus');

                if (responseText && responseText !== 'Response will appear here...' && responseText !== 'Loading...') {
                    navigator.clipboard.writeText(responseText)
                        .then(() => {
                            statusElement.textContent = 'Response copied to clipboard!';
                            setTimeout(() => {
                                statusElement.textContent = '';
                            }, 3000);
                        })
                        .catch(err => {
                            console.error('Could not copy text: ', err);
                            statusElement.textContent = 'Could not copy text';
                            setTimeout(() => {
                                statusElement.textContent = '';
                            }, 3000);
                        });
                }
            }
            
            // Function to count words in text, handling both HTML and plain text
            function countWords(text) {
                // If it's HTML content, extract the text
                if (text.includes('<') && text.includes('>')) {
                    const tempElement = document.createElement('div');
                    tempElement.innerHTML = text;
                    text = tempElement.textContent || tempElement.innerText;
                }
                
                text = text.trim();
                if (!text) return 0;
                return text.split(/\s+/).length;
            }
            
            // Add debug button for API troubleshooting
            function addDebugFeatures() {
                const debugBtn = document.createElement('button');
                debugBtn.id = 'debugBtn';
                debugBtn.textContent = 'Debug API Connection';
                debugBtn.style.backgroundColor = '#f0ad4e';
                debugBtn.style.marginTop = '10px';
                debugBtn.style.marginRight = '10px';
                
                const copyPromptBtn = document.createElement('button');
                copyPromptBtn.id = 'copyPromptBtn';
                copyPromptBtn.textContent = 'Copy Last Prompt';
                copyPromptBtn.style.backgroundColor = '#5bc0de';
                copyPromptBtn.style.marginTop = '10px';
                
                const status = document.getElementById('status');
                status.parentNode.insertBefore(debugBtn, status);
                status.parentNode.insertBefore(copyPromptBtn, status);
                
                debugBtn.addEventListener('click', async function() {
                    const statusEl = document.getElementById('status');
                    const apiKey = document.getElementById('apiKey').value;
                    
                    if (!apiKey) {
                        statusEl.textContent = 'Please enter an API key first';
                        return;
                    }
                    
                    statusEl.textContent = 'Testing API connection...';
                    
                    try {
                        // Simple health check request
                        const response = await fetch('https://openrouter.ai/api/v1/auth/key', {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`
                            }
                        });
                        
                        const data = await response.json();
                        console.log('API Key info:', data);
                        
                        if (response.ok) {
                            statusEl.textContent = 'API connection successful! Check console for details.';
                        } else {
                            statusEl.textContent = `API Error: ${data.error?.message || 'Unknown error'}`;
                        }
                    } catch (error) {
                        statusEl.textContent = `Connection error: ${error.message}`;
                        console.error('Debug error:', error);
                    }
                });
                
                copyPromptBtn.addEventListener('click', function() {
                    const lastSentPrompt = document.getElementById('lastSentPrompt');
                    const statusEl = document.getElementById('status');
                    
                    if (lastSentPrompt.value && lastSentPrompt.value !== 'No messages sent yet.') {
                        navigator.clipboard.writeText(lastSentPrompt.value)
                            .then(() => {
                                statusEl.textContent = 'Last prompt copied to clipboard!';
                                setTimeout(() => {
                                    statusEl.textContent = '';
                                }, 3000);
                            })
                            .catch(err => {
                                console.error('Could not copy text: ', err);
                                statusEl.textContent = 'Could not copy text';
                            });
                    } else {
                        statusEl.textContent = 'No prompt to copy';
                        setTimeout(() => {
                            statusEl.textContent = '';
                        }, 3000);
                    }
                });
            }

            // Function to send request to OpenRouter API
            async function sendAIRequest(prompt, apiKey, siteUrl, siteName, model, isDebugMode = false) {
                try {
                    console.log('Sending request to OpenRouter API:', {
                        model: model,
                        prompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : '')
                    });
                    
                    const requestBody = {
                        model: model,
                        messages: [
                            {
                                role: 'user',
                                content: prompt
                            }
                        ]
                    };
                    
                    console.log('Full request body:', JSON.stringify(requestBody));
                    
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'HTTP-Referer': siteUrl,
                            'X-Title': siteName
                        },
                        body: JSON.stringify(requestBody)
                    });

                    console.log('Response status:', response.status);
                    
                    // Get the raw response text for debugging
                    const responseText = await response.text();
                    console.log('Raw response:', responseText);
                    
                    // Try to parse the response as JSON
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Error parsing JSON response:', e);
                        throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
                    }
                    
                    if (!response.ok) {
                        const errorMessage = data.error?.message || `HTTP error! status: ${response.status}`;
                        console.error('API error:', errorMessage);
                        throw new Error(errorMessage);
                    }
                    
                    // Validate the response structure
                    if (!data || !data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
                        console.error('Unexpected API response format:', data);
                        throw new Error('Received an invalid response from the API');
                    }
                    
                    const firstChoice = data.choices[0];
                    if (!firstChoice.message || typeof firstChoice.message.content !== 'string') {
                        console.error('Response missing expected content:', firstChoice);
                        throw new Error('Response did not contain the expected content');
                    }
                    
                    console.log('Successfully received response');
                    return firstChoice.message.content;
                } catch (error) {
                    console.error('Error in sendAIRequest:', error);
                    throw error;
                }
            }

            // Function to create a placeholder logo
            function createPlaceholderLogo() {
                const canvas = document.createElement('canvas');
                const size = 100;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Background
                ctx.fillStyle = '#4285f4';
                ctx.fillRect(0, 0, size, size);
                
                // Text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('C', size/2, size/2);
                
                return canvas.toDataURL();
            }
        });
    </script>
    
    <!-- Firebase Configuration -->
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.5.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.5.0/firebase-analytics.js";
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries
      // Your web app's Firebase configuration
      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyBXphSbB2M6B5xROy_MaUb6Iv5bztqNn_c",
        authDomain: "cresonia-ai-prose-generation.firebaseapp.com",
        projectId: "cresonia-ai-prose-generation",
        storageBucket: "cresonia-ai-prose-generation.firebasestorage.app",
        messagingSenderId: "927498475279",
        appId: "1:927498475279:web:6912ef299cdd97df6f107a",
        measurementId: "G-87H6CFRZPF"
      };
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
    </script>
</body>
</html>
